/**************************************************************
 * Example: Main UML-Derived Classes for a Lawn Mowing Game
 * 
 * This sample code demonstrates how to interpret a UML diagram 
 * (as seen in your draw.io XML) and translate it into a C++ 
 * class structure. 
 * 
 * It includes:
 *  - Tile         (tracks height, grass depth, accessibility)
 *  - Player       (manages stamina, movement, current tool, etc.)
 *  - Tool         (base class for specialized mowers or rakes)
 *     - PushMower
 *     - WeedWacker
 *     - RidingMower
 *     - Rake
 *     - EmptyHanded
 *  - PlayerController (handles user input movement)
 *  - Truck        (allows swapping tools, ending level)
 *  - Scenes       (Pause, LoadingScene, GasStation, etc.)
 *  - UI classes   (Job_UI, Truck_UI, Job_Select_UI)
 *  - Others...
 *
 * This code does not represent a fully working game; rather, 
 * it provides a cohesive example of how you can map from UML 
 * to code. Fill in engine-specific logic, physics, rendering, 
 * or event callbacks as needed for your environment.
 **************************************************************/

#include <iostream>
#include <string>
#include <memory>
#include <vector>
#include <algorithm>

// Forward declarations
class Tool;
class Tile;

//----------------------------------------------------------
// Tile
//----------------------------------------------------------
class Tile {
public:
    int height = 0;
    int grassDepth = 0;
    Tool* reachableWith = nullptr; // If certain tools are required, store or handle logic.

    // Mow the tile => reduce grassDepth
    void mow() {
        if (grassDepth > 0) {
            grassDepth = 0;
            // Additional logic: maybe store cut clippings, etc.
        }
    }

    // For scoring or cost logic
    int getValue(Tool* tool) const {
        // Example: The tile’s “value” depends on the tool used
        // and the amount of grass depth. 
        // This is just a placeholder:
        int baseValue = 10;
        if (tool) {
            baseValue += tool->getFuelCost() - tool->getStaminaCost();
        }
        return baseValue - grassDepth;
    }
};

//----------------------------------------------------------
// Tool (abstract base class)
//----------------------------------------------------------
class Tool {
protected:
    int staminaCost;
    int fuelCost;
    int fuel;       // Current fuel
    int areaX;      // Horizontal coverage
    int areaY;      // Vertical coverage

public:
    Tool(int stamina, int fuelC, int startFuel, int aX, int aY)
        : staminaCost(stamina)
        , fuelCost(fuelC)
        , fuel(startFuel)
        , areaX(aX)
        , areaY(aY)
    {}

    virtual ~Tool() = default;

    int getStaminaCost() const { return staminaCost; }
    int getFuelCost() const    { return fuelCost;    }
    int getFuel()      const   { return fuel;        }
    int getAreaX()     const   { return areaX;       }
    int getAreaY()     const   { return areaY;       }

    // Decrease fuel based on usage
    virtual void burnFuel(int grassDepth) {
        // Basic logic: fuel cost * grassDepth => but each derived 
        // class might do something different.
        int cost = fuelCost + grassDepth / 2;
        if (fuel >= cost) {
            fuel -= cost;
        } else {
            // Possibly run out of fuel
            fuel = 0;
        }
    }

    // For some tools that can collect clippings
    virtual void collectClippings(int& /*playerClippings*/) {
        // Default: No clippings collected
    }
};

//----------------------------------------------------------
// Derived Tools
//----------------------------------------------------------
class PushMower : public Tool {
protected:
    int bagLevel; // capacity for clippings

public:
    PushMower()
        : Tool(/*stamina*/2, /*fuelC*/2, /*fuel*/50, /*areaX*/1, /*areaY*/1)
        , bagLevel(0)
    {}

    // override burnFuel if needed
    // override collectClippings
    void collectClippings(int& playerClippings) override {
        // Example: increment bag, then transfer to player
        bagLevel += 5;
        if (bagLevel > 10) {
            // move to player's clippings
            playerClippings += bagLevel;
            bagLevel = 0;
        }
    }
};

class WeedWacker : public Tool {
public:
    WeedWacker()
        : Tool(/*stamina*/3, /*fuelC*/1, /*fuel*/30, /*areaX*/1, /*areaY*/1)
    {}
};

class RidingMower : public Tool {
protected:
    int bagLevel;

public:
    RidingMower()
        : Tool(/*stamina*/0, /*fuelC*/3, /*fuel*/100, /*areaX*/2, /*areaY*/2)
        , bagLevel(0)
    {}

    void collectClippings(int& playerClippings) override {
        bagLevel += 10;
        if (bagLevel > 30) {
            playerClippings += bagLevel;
            bagLevel = 0;
        }
    }
};

class Rake : public Tool {
protected:
    int bagLevel;

public:
    Rake()
        : Tool(/*stamina*/2, /*fuelC*/0, /*fuel*/0, /*areaX*/1, /*areaY*/1)
        , bagLevel(0)
    {}

    void collectClippings(int& playerClippings) override {
        bagLevel += 3;
        if (bagLevel > 15) {
            playerClippings += bagLevel;
            bagLevel = 0;
        }
    }
};

class EmptyHanded : public Tool {
public:
    EmptyHanded()
        : Tool(/*stamina*/1, /*fuelC*/0, /*fuel*/0, /*areaX*/0, /*areaY*/0)
    {}
};

//----------------------------------------------------------
// Player
//----------------------------------------------------------
class Player {
public:
    int stamina      = 100;
    int tilesTraveled= 0;
    Tool* currentTool= nullptr; 
    Tile* currentTile= nullptr;
    Tile* lastTile   = nullptr;
    bool atTruck     = false;
    int clippingsWeight = 0; // total cut grass weight

    // A quick multiplier for slopes or other terrain changes
    float getStaMultiplier(int curHeight, int lastHeight) {
        int diff = curHeight - lastHeight;
        // Example logic: big difference => bigger stamina usage
        if (diff > 5)  return 1.5f;
        if (diff < -5) return 0.8f;
        return 1.0f;
    }

    // Deduct stamina
    void tire(int baseCost, float staMultiplier, int grassDepth) {
        // For demonstration: cost depends on grass depth, slope multiplier
        int cost = static_cast<int>( (baseCost + grassDepth) * staMultiplier );
        stamina = std::max(0, stamina - cost);
    }
};

//----------------------------------------------------------
// PlayerController
//----------------------------------------------------------
class PlayerController {
public:
    // The Player to move
    Player* player = nullptr;

    PlayerController(Player* p) : player(p) {}

    // Movement commands
    void moveRight() {
        // Implementation detail depends on your map, tile adjacency, etc.
        // For demonstration, just increment tileTraveled.
        if (player) {
            player->tilesTraveled += 1;
            // update tile references here
        }
    }
    void moveLeft()  { if (player) player->tilesTraveled += 1; }
    void moveDown()  { if (player) player->tilesTraveled += 1; }
    void moveUp()    { if (player) player->tilesTraveled += 1; }
};

//----------------------------------------------------------
// Truck
//----------------------------------------------------------
class Truck {
public:
    // Possibly hold multiple tools
    std::vector<std::unique_ptr<Tool>> storedTools;

    // Let the player pick (swap) a new tool
    void swapTool(Player& player, int toolIndex) {
        if (toolIndex >= 0 && toolIndex < static_cast<int>(storedTools.size())) {
            player.currentTool = storedTools[toolIndex].get();
            player.atTruck     = true; 
        }
    }

    // Load clippings from Player (e.g., sell them?)
    void loadClippings(Player& player) {
        // Example: Player’s clippings offloaded
        player.clippingsWeight = 0;
    }

    // End level or job
    void endLevel() {
        // Some logic for finalizing the level
        std::cout << "Level ended.\n";
    }

    // Example: let the player eat a snack to restore stamina
    void eatSnack(Player& player) {
        player.stamina += 10;
        if (player.stamina > 100) player.stamina = 100;
    }
};

//----------------------------------------------------------
// Scenes (very minimal stubs)
//----------------------------------------------------------
class Scene {
public:
    virtual ~Scene() = default;
    virtual void update() = 0;
};

class PauseScene : public Scene {
    void update() override {
        // Pause menu UI, wait for user input
    }
};

class GasStationScene : public Scene {
public:
    void update() override {
        // player can buy fuel, etc.
    }
};

// etc. for LoadingScene, Inventory, Options, etc.

//----------------------------------------------------------
// UI classes (job, truck, etc.) - stubs
//----------------------------------------------------------
class Job_UI {
public:
    int stamina;
    int fuelLevel;
    int money;
    int tilesTraveled;
    int clippingsWeight;
};

class Job_Select_UI {
public:
    void select_job() {
        // The player picks a job or mission
    }
};

class Truck_UI {
public:
    void eat_lunch() {
        // Possibly calls truck->eatSnack(player)
    }
};

class Gas_Station_UI {
public:
    void buy_fuel() {
        // logic for purchasing fuel
    }
    void buy_energy_drink() {
        // logic for purchasing a stamina item
    }
};

//----------------------------------------------------------
// A small demonstration of usage
//----------------------------------------------------------
int main() 
{
    // Create a few tiles
    Tile tile1{0, 10, nullptr};
    Tile tile2{5, 15, nullptr};

    // Create a few tools
    auto pushMower = std::make_unique<PushMower>();
    auto weedWacker= std::make_unique<WeedWacker>();

    // Create player, assign a default tool
    Player player;
    EmptyHanded emptyHand;
    player.currentTool = &emptyHand;
    player.currentTile = &tile1;
    player.lastTile    = &tile2;

    // Create a truck and store the tools
    Truck truck;
    truck.storedTools.push_back(std::move(pushMower));
    truck.storedTools.push_back(std::move(weedWacker));

    // Example: swap to a push mower
    truck.swapTool(player, 0);

    // Then the player can mow the tile
    player.currentTile->mow();
    player.currentTool->burnFuel(player.currentTile->grassDepth);
    player.tire(player.currentTool->getStaminaCost(), 
                player.getStaMultiplier(player.currentTile->height, 
                                        player.lastTile->height),
                player.currentTile->grassDepth);

    // Check results
    std::cout << "Player stamina: " << player.stamina << "\n";
    std::cout << "Player fuel (mower): " << player.currentTool->getFuel() << "\n";

    // Example end
    truck.endLevel();
    return 0;
}
